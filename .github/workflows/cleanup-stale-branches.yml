name: Cleanup Stale Branches

on:
  # Manual trigger with confirmation and configuration inputs
  workflow_dispatch:
    inputs:
      confirm_deletion:
        description: 'Type "DELETE" to confirm branch deletion'
        required: true
        type: string
      days_stale:
        description: 'Number of days a branch must be inactive to be considered stale'
        required: true
        type: number
        default: 90
      max_deletions:
        description: 'Maximum number of branches to delete in this run'
        required: true
        type: number
        default: 10
      exclude_patterns:
        description: 'Comma-separated patterns to exclude (e.g., main,master,develop,release/*,hotfix/*)'
        required: false
        type: string
        default: 'main,master,develop,release/*,hotfix/*'
      approver:
        description: 'GitHub handle or email of approver (leave empty to use repo admin as default)'
        required: false
        type: string

jobs:
  identify-stale-branches:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      stale_branches: ${{ steps.identify_stale.outputs.stale_branches }}
      identified_count: ${{ steps.identify_stale.outputs.identified_count }}
      skipped_count: ${{ steps.identify_stale.outputs.skipped_count }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all branches and history
      
      - name: Validate user confirmation
        run: |
          echo "::group::Validating User Confirmation"
          if [ "${{ inputs.confirm_deletion }}" != "DELETE" ]; then
            echo "‚ùå Deletion not confirmed. You must type 'DELETE' exactly to proceed."
            echo "You entered: '${{ inputs.confirm_deletion }}'"
            exit 1
          fi
          echo "‚úÖ User confirmation validated"
          echo "::endgroup::"
      
      - name: Display Configuration
        run: |
          echo "::group::Cleanup Configuration"
          echo "üìã Configuration Settings:"
          echo "  ‚Ä¢ Days Stale Threshold: ${{ inputs.days_stale }} days"
          echo "  ‚Ä¢ Maximum Deletions: ${{ inputs.max_deletions }} branches"
          echo "  ‚Ä¢ Exclude Patterns: ${{ inputs.exclude_patterns }}"
          echo "  ‚Ä¢ Approver: ${{ inputs.approver || 'Repo Admin (default)' }}"
          echo "  ‚Ä¢ Repository: ${{ github.repository }}"
          echo "  ‚Ä¢ Triggered by: ${{ github.actor }}"
          echo "::endgroup::"
      
      - name: Fetch all branches
        run: |
          echo "::group::Fetching Branch Information"
          git fetch --all --prune
          echo "‚úÖ All branches fetched"
          echo "::endgroup::"
      
      - name: Get protected branches
        id: protected_branches
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Identifying Protected Branches"
          
          # Get protected branches from GitHub API
          PROTECTED_BRANCHES=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/branches?protected=true" \
            --jq '.[].name' | tr '\n' ',' | sed 's/,$//')
          
          if [ -z "$PROTECTED_BRANCHES" ]; then
            echo "‚ÑπÔ∏è  No protected branches found via API"
            PROTECTED_BRANCHES=""
          else
            echo "üîí Protected branches: $PROTECTED_BRANCHES"
          fi
          
          echo "protected=$PROTECTED_BRANCHES" >> $GITHUB_OUTPUT
          echo "::endgroup::"
      
      - name: Get branches with open PRs
        id: pr_branches
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Identifying Branches with Open Pull Requests"
          
          # Get all branches that have open PRs
          PR_BRANCHES=$(gh pr list --state open --json headRefName --jq '.[].headRefName' | tr '\n' ',' | sed 's/,$//')
          
          if [ -z "$PR_BRANCHES" ]; then
            echo "‚ÑπÔ∏è  No branches with open pull requests"
            PR_BRANCHES=""
          else
            echo "üîÄ Branches with open PRs: $PR_BRANCHES"
          fi
          
          echo "branches=$PR_BRANCHES" >> $GITHUB_OUTPUT
          echo "::endgroup::"
      
      - name: Identify and process stale branches
        id: identify_stale
        env:
          DAYS_STALE: ${{ inputs.days_stale }}
          MAX_DELETIONS: ${{ inputs.max_deletions }}
          EXCLUDE_PATTERNS: ${{ inputs.exclude_patterns }}
          PROTECTED_BRANCHES: ${{ steps.protected_branches.outputs.protected }}
          PR_BRANCHES: ${{ steps.pr_branches.outputs.branches }}
        run: |
          echo "::group::Identifying Stale Branches"
          
          # Note: Using GNU date syntax - works on ubuntu-latest runner
          CUTOFF_DATE=$(date -d "$DAYS_STALE days ago" +%s)
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          echo "üìÖ Cutoff date: $(date -d "@$CUTOFF_DATE" "+%Y-%m-%d %H:%M:%S")"
          echo "üåø Current branch: $CURRENT_BRANCH"
          echo ""
          
          # Convert comma-separated lists to arrays
          IFS=',' read -ra EXCLUDE_ARRAY <<< "$EXCLUDE_PATTERNS"
          IFS=',' read -ra PROTECTED_ARRAY <<< "$PROTECTED_BRANCHES"
          IFS=',' read -ra PR_ARRAY <<< "$PR_BRANCHES"
          
          IDENTIFIED_COUNT=0
          SKIPPED_COUNT=0
          STALE_BRANCHES=()
          
          echo "üîç Analyzing branches..."
          echo ""
          
          # Get all remote branches, excluding symbolic refs and HEAD
          # Using while-read loop to avoid word-splitting issues
          while IFS= read -r branch; do
            # Skip if branch name is empty, HEAD, or origin
            if [ -z "$branch" ] || [ "$branch" = "HEAD" ] || [ "$branch" = "origin" ]; then
              continue
            fi
            
            # Verify the branch actually exists on the remote
            if ! git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Skipping invalid reference: $branch"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi
            
            # Skip current branch
            if [ "$branch" == "$CURRENT_BRANCH" ]; then
              echo "‚è≠Ô∏è  Skipping current branch: $branch"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi
            
            # Check if branch is protected
            IS_PROTECTED=false
            for protected in "${PROTECTED_ARRAY[@]}"; do
              if [ "$branch" == "$protected" ]; then
                IS_PROTECTED=true
                break
              fi
            done
            
            if [ "$IS_PROTECTED" == "true" ]; then
              echo "üîí Skipping protected branch: $branch"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi
            
            # Check if branch has an open PR
            HAS_OPEN_PR=false
            for pr_branch in "${PR_ARRAY[@]}"; do
              if [ "$branch" == "$pr_branch" ]; then
                HAS_OPEN_PR=true
                break
              fi
            done
            
            if [ "$HAS_OPEN_PR" == "true" ]; then
              echo "üîÄ Skipping branch with open PR: $branch"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi
            
            # Check exclude patterns
            EXCLUDED=false
            for pattern in "${EXCLUDE_ARRAY[@]}"; do
              # Remove whitespace
              pattern=$(echo "$pattern" | xargs)
              
              # Handle glob patterns
              if [[ "$pattern" == *"*"* ]]; then
                # Convert glob to regex (replace * with .*)
                pattern_regex="${pattern//\*/.*}"
                if [[ "$branch" =~ ^${pattern_regex}$ ]]; then
                  EXCLUDED=true
                  break
                fi
              else
                # Exact match
                if [ "$branch" == "$pattern" ]; then
                  EXCLUDED=true
                  break
                fi
              fi
            done
            
            if [ "$EXCLUDED" == "true" ]; then
              echo "‚õî Skipping excluded pattern: $branch"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi
            
            # Check if branch is stale
            LAST_COMMIT_DATE=$(git log -1 --format=%ct origin/$branch 2>/dev/null || echo "0")
            
            if [ "$LAST_COMMIT_DATE" -lt "$CUTOFF_DATE" ]; then
              LAST_COMMIT_DATE_HUMAN=$(date -d "@$LAST_COMMIT_DATE" "+%Y-%m-%d %H:%M:%S")
              DAYS_OLD=$(( ($(date +%s) - LAST_COMMIT_DATE) / 86400 ))
              
              # Check deletion limit
              if [ "$IDENTIFIED_COUNT" -ge "$MAX_DELETIONS" ]; then
                echo "‚ö†Ô∏è  Identification limit ($MAX_DELETIONS) reached. Stopping."
                break
              fi
              
              echo "üóëÔ∏è  Stale branch found: $branch (last commit: $LAST_COMMIT_DATE_HUMAN, $DAYS_OLD days old)"
              STALE_BRANCHES+=("$branch")
              IDENTIFIED_COUNT=$((IDENTIFIED_COUNT + 1))
            fi
          done < <(git for-each-ref --format='%(refname:lstrip=3)' refs/remotes/origin/)
          
          echo ""
          echo "::endgroup::"
          
          echo "::group::Summary"
          echo "üìä Identification Summary:"
          echo "  ‚Ä¢ Stale branches identified: ${#STALE_BRANCHES[@]}"
          echo "  ‚Ä¢ Branches skipped: $SKIPPED_COUNT"
          
          echo ""
          echo "Stale branches list:"
          if [ ${#STALE_BRANCHES[@]} -eq 0 ]; then
            echo "  ‚úÖ No stale branches found"
          else
            for branch in "${STALE_BRANCHES[@]}"; do
              echo "  ‚Ä¢ $branch"
            done
          fi
          echo "::endgroup::"
          
          # Set outputs - convert array to JSON for passing between jobs
          STALE_BRANCHES_JSON=$(printf '%s\n' "${STALE_BRANCHES[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "stale_branches=$STALE_BRANCHES_JSON" >> $GITHUB_OUTPUT
          echo "identified_count=$IDENTIFIED_COUNT" >> $GITHUB_OUTPUT
          echo "skipped_count=$SKIPPED_COUNT" >> $GITHUB_OUTPUT
          
          # Ensure successful exit
          exit 0
      
      - name: Identification Summary
        run: |
          echo "::notice::Identification completed. Found: ${{ steps.identify_stale.outputs.identified_count }} stale branches, Skipped: ${{ steps.identify_stale.outputs.skipped_count }} branches"
          echo "::notice::Awaiting approval to delete identified stale branches."
  
  delete-stale-branches:
    runs-on: ubuntu-latest
    needs: identify-stale-branches
    if: fromJSON(needs.identify-stale-branches.outputs.identified_count) > 0
    # Use environment to require approval before deletion
    environment:
      name: stale-branch-deletion-approval
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Display approval information
        run: |
          echo "::group::Approval Information"
          echo "‚úÖ Approval received for branch deletion"
          if [ -n "${{ inputs.approver }}" ]; then
            echo "  ‚Ä¢ Approver configured: ${{ inputs.approver }}"
          else
            echo "  ‚Ä¢ Approver: Repo Admin (default)"
          fi
          echo "  ‚Ä¢ Branches to delete: ${{ needs.identify-stale-branches.outputs.identified_count }}"
          echo "::endgroup::"
      
      - name: Delete stale branches
        env:
          STALE_BRANCHES: ${{ needs.identify-stale-branches.outputs.stale_branches }}
        run: |
          echo "::group::Deleting Stale Branches"
          
          # Parse JSON array of branch names
          BRANCHES=$(echo "$STALE_BRANCHES" | jq -r '.[]')
          
          DELETED_COUNT=0
          FAILED_COUNT=0
          
          echo "üóëÔ∏è  Starting branch deletion process..."
          echo ""
          
          while IFS= read -r branch; do
            if [ -n "$branch" ]; then
              echo "Deleting branch: $branch"
              if git push origin --delete "$branch" 2>&1; then
                echo "  ‚úÖ Successfully deleted: $branch"
                DELETED_COUNT=$((DELETED_COUNT + 1))
              else
                echo "  ‚ùå Failed to delete: $branch"
                FAILED_COUNT=$((FAILED_COUNT + 1))
              fi
            fi
          done <<< "$BRANCHES"
          
          echo ""
          echo "::endgroup::"
          
          echo "::group::Deletion Summary"
          echo "üìä Deletion Results:"
          echo "  ‚Ä¢ Successfully deleted: $DELETED_COUNT branches"
          echo "  ‚Ä¢ Failed to delete: $FAILED_COUNT branches"
          echo "::endgroup::"
          
          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "::warning::Some branches failed to delete. Check the logs above for details."
          fi
